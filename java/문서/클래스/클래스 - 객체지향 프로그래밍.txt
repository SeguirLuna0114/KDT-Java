클래스 - 객체지향 프로그래밍
# 클래스 = 객체 생성을 위한 자바의 설계도
- 인스턴스 : 클래스로부터 만들어진 객체
- 클래스 변수에 저장하여 변수 통해 객체 사용가능
- 객체지향 프로그래밍 단계) 클래스 설계 -> 클래스로 사용할 객체 생성 -> 객체 이용
- 용도) 	1. 라이브러리(API) 클래스: 객체 생성 및 메소드 제공 역할
	2. 실행 클래스: 메인 메소드 제공 역할 

# 객체(Object) = 클래스의 인스턴스
- 클래스에 의해 정의된 데이터 + 메서드 포함
  => 클래스에 의해 생성되고, "실제 메모리에 할당된 것"을 의미
- 속성(필드field)+동작(메소드method)로 구성됨
			
###동작(메소드method): 객체의 동작에 해당하는 실행블록
- 객체는 동작을 갖고 작업을 수행
   ex) 자동차 클래스의 객체의 행위 = 가속, 감속, 정지

### 속성/특정상태(필드field) : 객체의 데이터(state상태)가 저장되는 "인스턴스 변수"
- 인스턴스 변수는 해당 객체의 클래스에 선언되어, 클래스의 모든 인스턴스가 공유하는 속성 의미
   ex) 자동차 클래스의 객체의 속성 = 차의 색상, 속도, 모델
- this 키워드: 클래스의 인스턴스 내부에서 사용됨
	      => 인스턴스 변수 참조 or 인스턴스 메소드 호출
	      현재 실행중인 메소드나 생성자가 속한 객체 참조
 ex) public MyDate(int year, int month, int day) {
		// 생성자 매개변수 - year, month, day
    		this.year = year;	// 현재 객체의 year필드
   		this.month = month;
    		this.day = day;
     }


- 필드의 종류: 인스턴스 변수/필드, 클래스 변수/필드
1. 인스턴스 변수/필드: 객체의 속성/상태를 나타내는 데이터를 저장하는 변수
     - 클래스의 인스턴스(객체)가 생성될 때, heap메모리에 저장됨
ex)
class Car{	
	// 비공개 클래스로 작성 => 독립적으로 사용X(동일 파일 내 다른 클래스에서만 접근 가능)
	// 필드(field)
	String company = "현대자동차";
	String model = "그랜저";
	String color = "검정";
	int maxSpeed = 350;
	int speed;			// 초기값 0으로 설정됨
}
public class CarExample_2class {

	public static void main(String[] args) {
		// => 해당 클래스의 인스턴스 생성&초기화
		Car mycar = new Car();	
=> 이때 Car클래스의 인스턴스인 mycar객체의 company, model, color, maxspeed는 인스턴스변수

2. 클래스 변수(정적필드): 클래스의 모든 인스턴스들이 공유하는 데이터를 저장하기 위한 변수
   - 클래스가 메모리에 로드될 때 클래스 영역에 저장됨
   - 클래스 이름을 통해 접근 가능
    ex) Car.company: Car클래스의 클래스변수인 company에 접근하는 것
cf> 지역변수는 메서드나 블록 내에서 선언된 변수. 실행될 때 Stack메모리에 할당됨
ex)
public class Counter {
    // 클래스 변수
    public static int count;

    // 메서드
    public void increment() {
        count++; // 클래스 변수 값 증가
    }
    public void decrement() {
        count--; // 클래스 변수 값 감소
    }

    public static void main(String[] args) {
        Counter counter1 = new Counter();
        Counter counter2 = new Counter();

        // 클래스 변수(count) 접근
        System.out.println("counter1의 count: " + counter1.count); // 출력: 0
        System.out.println("counter2의 count: " + counter2.count); // 출력: 0

        counter1.increment(); // 클래스 변수(count) 값 증가
        counter2.increment(); // 클래스 변수(count) 값 증가

        System.out.println("counter1의 count: " + counter1.count); // 출력: 2
        System.out.println("counter2의 count: " + counter2.count); // 출력: 2
    }
}


-필드의 특징
1. 접근제어자: 접근 제어자를 통해 해당 필드에 접근할 수 있는 범위 제어
   (필드가 외부에서 직접 접근 가능한지 여부 결정)
   - public, private, protected, default
ex) public class Person {
    	private String name;  // private 접근 제어자를 가진 필드

   	 // Getter와 Setter 메서드를 통해 name 필드에 접근 및 수정
    	public String getName() {
        	return name;
    	}
    	public void setName(String name) {
        	this.name = name;
   	}
    }


2. 데이터 타입: 특정 데이터 타입의 값만 저장 가능
    -기본 데이터타입 & 참조 데이터타입(String, 배열, 사용자정의클래스)을 사용 가능
ex) public class Circle {
    	private int radius;  // int 타입의 필드

    	// Getter와 Setter 메서드를 통해 radius 필드에 접근 및 수정
    	public int getRadius() {
        	return radius;
    	}
    	public void setRadius(int radius) {
        	this.radius = radius;
    	}
    }


3. 초기값: 선언시 초기값을 가질 수 있음
  -초기값을 지정하지 않으면, 해당 데이터 타입에 따라 기본값이 할당됨
   ex) int형의 필드는 0, boolean형의 필드는 false

4. 인스턴스 변수
   : 필드는 객체의 인스턴스 변수로서 객체 생성될 때마다 해당 인스턴스에 대한 개별적인 값을 가짐
   - 객체의 상태를 유지하고, 객체 간의 데이터를 공유하는 데 사용
ex) public class Student {
    	private String name;  // String 타입의 필드 (인스턴스 변수)
    	private int age;      // int 타입의 필드 (인스턴스 변수)
    }


5. 접근 및 수정
     : 해당 필드에 대한 접근자(Getter)와 설정자(Setter)메서드 사용
  -접근자: 필드의 값 반환
   -설정자: 필드의 값 변경

## 클래스로부터 객체 생성
- new() 클래스: new 연산자로 메모리 힙 영역에 객체 생성
- 객체는 Heap메모리에 할당되며, 객체 생성을 위해 new연산자를 사용하여 클래스 생성자(constructor)를 호출해야 함
-생성자: 클래스 내 특별한 메서드. 객체를 초기화하는 역할 수행

	// 객체 생성을 위해 클래스의 생성자 호출 = 해당 클래스의 인스턴스 생성&초기화
ex)	클래스명		레퍼런스변수	=	new연산자	생성자 호출
	  Car		    car		=	  new		  Car();
	Animal		     a1		=	  new		Animal();
	-new 연산자 뒤에는 생성하려는 클래스의 이름과 괄호()를 붙인 생성자를 호출
	  => 해당 클래스의 인스턴스가 생성됨
	-객체를 위해 할당된 메모리에서 해당 객체의 생성자가 호출됨 
	  -> 객체는 초기화한 상태로 사용가능
	   => 객체 변수에 할당되거나 다른 객체의 속성으로 사용 가능	

- 생성된 객체는 변수에 할당되거나 다른 객체의 속성으로 사용될 수 있음


### 객체 간의 관계 - 객체는 복잡한 시스템 구현을 위해 객체 간 관계를 형성하기도 함
1. 집합 관계(Composition): 부품과 완성품의 관계
   - 한 객체가 다른 객체를 포함하는 것
     ex) 자동차 객체는 엔진 객체를 포함. 엔진 객체는 자동차 없이 존재X
   - 전체 객체와 부분 객체가 생명주기 공유

2. 사용 관계: 객체간의 상호작용
     ex) 사람 객체는 자동차 객체를 사용

3. 상속관계(Inheritance): 한 클래스가 다른 클래스로부터 특성과 동작을 상속받는 관계
   - 기존 클래스를 확장하거나 수정하지 않고, 새로운 클래스 정의가 가능
     - 상위 객체를 기반으로 하위 객체 생성
     - 자식(하위) 클래스는 부모(상위) 클래스의 특성과 동작 그대로 사용 가능
     ex) 자동차객체는 기계객체에 상속됨

4. 객체 지향 프로그래밍: 집합/사용 관계에 있는 객체를 하나씩 설계한 후 조립
###객체와 객체 간의 상호작용 -메소드를 통해 객체들이 상호작용
"객체 지향 프로그래밍"
-객체는 클래스에서 정의된 메소드 호출 -> 인스턴스 변수에 접근 -> 데이터 조작 가능
-메소드 호출 = 객체가 다른 객체의 기능을 이용하는 것




