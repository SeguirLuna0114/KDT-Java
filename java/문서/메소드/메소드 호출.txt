메소드 호출
   (Call by Value, Call by Reference, varargs)

# 사용자 정의 메소드
-사용자 정의 메소드는 프로그래머가 직접 호출해야 실행 됨
-static으로 선언됨 => 클래스에 직접적으로 연결됨
  (클래스의 인스턴스 생성 없이도 check()메소드 호출 가능)
-반환타입 'void': 메소드가 반환하는 값이 없음. 
  void반환 타입을 가지는 메소드는 명시적으로 return구문 작성하지 않아도 됨

# return구문: 메소드를 호출한 곳에 값을 돌려주는 역할
-return문은 메소드 가장 마지막줄에 사용해야 함

# 가변 인자(varargs) 방식 : int ... values
- 메소드가 동일한 타입의 여러 인자를 받을 수 있도록 해줌
- 메소드 호출 시, 배열을 생성하거나 직접 전달할 필요 없이 인자를 콤마(,)로 구분하여 전달 가능
- 가변인자들은 메소드 내에서 배열처럼 다룰 수 있음
-장점	1. 매개변수가 일정하지 않은 경우에도 동적으로 지정 가능해 유용
	2. 인자들을 쉼표로 구분해 메소드호출이 가능
-단점	1. 메소드 오버로딩 사용시, 가변인자 메소드와 일반 메소드가 혼동될수 있음
	2. 내부적으로 배열이 생성되므로, 약간의 오버헤드 발생 가능

ex)	int sum2(int ... values) {
		int sum = 0;
		for (int i=0; i<values.length; i++) {
			sum += values[i];		// sum = sum + values[i]
		}
		return sum;
	}

 	// main메소드에서 호출
	// 가변인자를 매개변수로 사용 => 배열을 생성 or 인자를 쉼표로 구분해 전달 가능
	int result3 = mycom.sum2(1, 2, 3);	// 인자를 쉼표로 구분하여 전달
	System.out.println("result3: "+result3);	// result3: 6
		
	int result4 = mycom.sum2(1, 2, 3, 4, 5);	// 인자를 쉼표로 구분하여 전달
	System.out.println("result4: "+result4);	// result4: 15


# Call by Value방식 - 값 전달에 의한 전달 메소드 호출방식
- 기본 데이터타입(int, double, boolean등)과 같은 값을 저장하는 변수에 대해 적용
- 값을 복사하여 전달하는 방식=> 호출자의 변수에는 영향X
ex) 	static void check(int a) {	// 매개변수(parameter): int a 사용
		System.out.println("전달된 값: "+a);
		// 호출시 check(값)과 같이 인수로 전달된 값을 매개변수a에 복사
	}


# Call by Reference방식 - 주소값 전달에 의한 메소드 호출방식
- 메소드 호출 시, 호출자가 전달한 변수의 참조(주소)가 메소드로 전달되어 메소드 내부에서 해당 변수에 대한 변경이 가능해짐
 (메소드 내에서 변수의 값이 변경되면, "호출자 변수에도 영향을 줌")
- 주소(참조)가 메소드로 전달됨(참조형 변수를 사용하면, 해당 변수는 객체의 주소를 가리킴)
ex) 		check("자바");				
		// String s = "자바": 자바라는 문자열을 인수로 전달
		// 문자열 그대로의 "자바"가 인수로 전달됨 -> 내부적으로 String객체로 변환되어 해당 객체의 주소가 메소드로 전달
		// (check 메소드 내에서 s는 "자바"라는 문자열을 가리키는 주소를 가짐
		
		check(new String("자바"));	
		// String s = new String("자바"): new String("자바")를 인수로 전달
		// (check 메소드 내에서 s는 새로 생성된 String객체의 주소를 가짐)
		// => 두 코드는 값은 같지만 주소는 다름

# 메소드에 매개변수가 존재하는 경우(리턴값O)
1. 리턴값을 받을 변수를 생성하여 이를 메소드에 전달
ex)	int[] values1 = {1, 2, 3};	// int형식의 배열변수 생성 -> 요소 초기화
	int result1 = mycom.sum1(values1);	// values1배열을 sum1메소드에 전달하여 호출
	System.out.println("result1: "+result1);

2. 리턴값을 직접 메소드 호출시에 인라인으로 생성하여 전달
ex)	int result2 = mycom.sum1(new int[] {1,2,3,4,5});
	// 데이터형식의 배열을 직접 인라인으로 작성시, new연산자를 사용하여 메모리에 할당
	System.out.println("result2: "+result2);


# 메소드 오버로딩(Method Overloading): 한개의 클래스 내에 "동일 이름" 메소드 여러개 정의
- 같은 이름의 메소드를 여러개 선언하여 매개값을 다양하게 받아 처리하기 위함
- 메소드 오버로딩 조건 : 매개변수 타입, 개수, 순서 증 하나는 서로 다른경우 사용 가능
	1. 매개변수의 "자료형"을 다르게 설정
	2. 매개변수의 "갯수"를 서로 다르게 설정
	3. 매개변수의 "순서"를 바꾸어서 설정(매개변수 자료형이 다를 경우)

ex) 	static void check(int a, double d) {
		double result =  a+d;			// 지역변수
		System.out.println("전달된 값의 합: "+result);
	}
	
	static void check(char c) {		// 매개변수 char c = 'A' 전달
		System.out.println("전달된 값: " + c);
	}


# 클래스 내부에서 다른 메소드 호출 => 인스턴스 메소드 사용
-인스턴스 메소드: 메소드명으로 호출되는 메소드
		-클래스의 인스턴스(객체)에 의해서만 호출 가능
		-해당 객체의 상태를 변경하거나, 해당 객체 관련 기능(메소드) 수행

1. 동일 클래스 내부에서 다른 메소드 호출 => 메소드명 만으로 호출 가능
- 클래스의 인스턴스(객체)에서 메소드를 호출하는 것이기 때문
ex) public class MyClass {
    	public void method1() {
        	System.out.println("메소드 1 실행");
    	}

    	public void method2() {
        	System.out.println("메소드 2 실행");
		// 동일 클래스 내부에서는 메소드명만으로 호출가능
        	method1(); // 메소드명만으로 호출가능
    	}

2. 다른 클래스의 메소드 호출 => 해당 클래스로 객체를 생성해야 함
- main()메소드에서 다른 클래스의 메소드 호출을 위해선 해당 클래스의 인스턴스(객체)를 생성해야함
- 메소드를 가진 클래스의 인스턴스(객체)를 생성
ex)	Calculator1 mycal = new Calculator1();	// Calculator1 클래스의 인스턴스 생성
- 생성한 인스턴스를 통해 메소드 호출
ex)	mycal.execute();


