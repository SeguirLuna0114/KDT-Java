* 자료구조(Data Structure)
   java.util.*;

   ex) Set, List, Vector, Map, Queue, Stack etc

# 제네릭(Generic) <>
  : 데이터 타입을 일반화하여, 자료구조에 1가지 자료형의 데이터만 저장할 수 있도록 함


iii. Vector 클래스
 "크기 조절이 가능하여 다양한 메소드를 제공해 벡터원소를 추가, 삭제, 접근하는 작업 가능"

     1.여러가지 자료형의 Data를 모두 저장할 수 있다.
      ex) int, double, char, boolean, String etc
     2. 순서있는 입.출력 처리(index번호 순으로 저장됨)
     3. 중복된 Data를 저장 할 수 있다.
	- Vector 클래스는 List 인터페이스를 구현한 클래스로, 
	  동적 배열(dynamic array)의 형태로 원소들을 저장하고 관리


## Vector클래스 객체생성
case1) 제네릭을 활용하지X
	- 이 경우엔 Vector에 어떤 타입의 객체도 저장O
	- 하지만, 객체를 꺼낼때 형변환을 해야하며 잘못된 타입을 저장할 수 있다는 위험

ex)	// 기본적인 비어있는 Vector객체 생성
	Vector vector = new Vector();

	// 제네릭을 사용하지 않아, 여러 타입의 원소 저장 가능
	vector.add(1);
	// 단, 객체를 꺼낼 때 형변환 필요
	int element1 = (int) vector.get(0); // 형변환 필요

ex)	// 초기 capacity만 지정한 Vector객체 생성
	// 초기 capa를 3으로 지정하여 Vector객체 생성
	Vector vector2 = new Vector(3);		

	System.out.println("size2=" + vector2.size());			// 0
	System.out.println("capacity2=" + vector2.capacity());		// 3

ex)	// 초기 capacity와 증가 capacity를 지정한 생성 방법
	// 초기 capa를 1로 지정하고, 증가 capa를 1로 지정하여 Vector 객체를 생성
	Vector vector3 = new Vector(1, 1);
	- 증가 capa: Vector의 크기가 초과될 때, capa를 얼마 증가시킬지 의미
	

case2) 제네릭을 활용하여 객체 생성
	- Generic(제네릭)클래스이기에, 생성자 호출 시, 타입파라미터를 지정하여 
  	  어떤 타입의 요소를 저장할 지 지정해줘야 함
 	- 타입 파라미터로는 '클래스 이름' 이나 '기본 데이터타입'등을 사용 가능

ex)	기본데이터타입을 활용하여 객체 생성
	// Integer 타입의 원소를 가진 1차원 벡터를 생성

	Vector<Integer> vector = new Vector<>();

	// Integer 타입의 원소만 저장 가능
	vector.add(1);
	int element = vector.get(0); // 형변환 불필요


case3)	클래스를 활용하여 객체 생성
	(타입파라미터 - '클래스')
	- 클래스를 활용하여, 기존에 정의된 클래스타입을 사용 가능

ex)	제네릭을 사용하여 Vector 클래스를 생성하고,
	Board 클래스 객체를 저장하는 리스트를 생성
	- Vector클래스를 Board클래스타입으로 구제화 했기에, Board객체만 저장 가능

	Vector<Board> list = new Vector<>();
	// Board 클래스 타입의 객체만을 원소로 갖는 벡터리스트가 생성됨


ex)	List인터페이스를 구현한 Vector클래스 사용하여
	Board클래스의 객체를 저장하는 list 생성
	- List<Board>: 제네릭을 사용하여 List인터페이스를 Board클래스 타입으로 구체화
	- Vector<Board>(): Vector클래스를 Board클래스 타입으로 구체화하여 객체 생성
	- List 인터페이스를 사용하기 때문에 Vector 클래스의 다양한 메서드와
	    List 인터페이스가 정의한 메서드를 모두 사용 가능
	- 업캐스팅: Vector 클래스가 List 인터페이스를 구현한 구현체이기 때문에, 
		   Vector 객체를 List 인터페이스로 참조하는 것은 업캐스팅
	
	// Board클래스 객체만을 저장 가능한 list 생성
	List<Board> list = new Vector<Board>();

	-객체 추가하는 방법1) Board클래스의 객체를 생성하여 리스트에 추가
	Board board1 = new Board("제목1", "내용1", "글쓴이1");
	list.add(board1);

	-객체 추가하는 방법2) new Board()로 새로운 Board 객체를 생성하여 리스트에 추가
	// list는 Vector<Board>타입으로 선언되었기에 Board클래스 객체만 저장 가능
	// new Board()를 이용해 새로운 Board객체 생성 -> list.add()메소드 이용해 추가
	list.add(new Board("제목1", "내용1", "글쓴이1"));
	


## Vector클래스의 주요 메소드
1. 크기와 용량
	- int size(): 벡터에 포함된 원소의 개수 반환
	- int capacity(): 벡터가 현재 저장할 수 있는 원소의 개수 반환(기본 용량은 10)

2. 원소 추가 및 삭제
	- boolean add(Object e): 벡터에 원소를 추가		(addElement()메소드와 동일)
	- boolean remove(Object e): 벡터에서 주어진 원소를 삭제
	- Object remove(int index): 해당 인덱스에 위치한 원소를 삭제

3. 원소 접근
	- Object set(int index, Object element)
				: Vector의 특정 인덱스에 해당하는 요소를 새로운 요소로 변경
				- 변경 전에 해당 인덱스에 위치한 요소는 반환됨
	
	- Object firstElement(): 벡터의 첫 번째 요소를 반환하는 메소드
				벡터가 비어있지 않은 경우에만 첫번째 요소 반환
				벡터가 비어있는 경우에는 noSuchElementException예외
	- Object lastElement(): 벡터의 마지막 요소를 반환하는 메소드
				벡터가 비어있지 않은 경우에만 마지막 요소 반환
				벡터가 비어있는 경우에는 noSuchElementException예외
	
	- int indexOf(Object e): 특정 객체 e가 처음으로 나타나는 인덱스를 찾아 반환
			    	 해당 값이 없으면 -1을 반환
				- 비교는 equals() 메서드를 사용하여 수행
	- Object elementAt(int index):  Vector에서 특정 인덱스에 해당하는 요소를 반환
	  **(get메소드와 기능적으로 동일하나, 일반적으로 get()메소드 사용)
	
	- Object get(int index): 주어진 인덱스에 해당하는 원소를 반환
	* 제네릭 사용시, get메소드를 활용한 원소접근 방법
	  -1) 제네릭 사용하지 않고, 객체를 구체화하지 않은 경우
	      	- 모든 객체를 Object 타입으로 다룸
		  => get()메소드로 반환된 값은 Object형
		  => 반환된 객체를 원래 타입으로 "다운캐스팅" 필요
		ex)	Vector vector = new Vector();
			vector.add("Hello");
			vector.add(42);
			String str = (String)vector.get(i);
			Integer num = (Integer)vector.get(i);
			
	
	  -2) 제네릭을 사용해, 객체의 타입을 구체화한 경우
		- get()메소드로 반환된 객체는 Board클래스의 객체
		  => 바로 Board타입 변수인 board에 할당 가능(형변환/다운캐스팅 필요X)
		ex) 	List<Board> list = new Vector<Board>();
			Board board = list.get(i);	// 다운캐스팅 필요X

4. 기타
	- boolean isEmpty(): Vector가 비어있는 경우 true를 반환하고,
			     요소가 하나라도 있는 경우 false를 반환


## Vector 순회(원소 접근 방법)
case1) vector 자료구조에 저장된 데이터를 "한줄로" 출력
ex)	Vector v = new Vector();
	v.add(30);
	v.addElement(new Integer(10));	// vector에 정수 10을 저장(기존 add메소드와 동일)
	
	System.out.println(v);		// [30, 10]


case2) 일반적인 for루프나 향상된 for문을 이용하여 벡터 순회 가능
ex)	// 일반적인 for 루프
	// vector.size()메소드를 활용하여 벡터의 원소만큼 for문 반복
	for (int i = 0; i < vector.size(); i++) {
    		int element = vector.get(i);
    		// 원소에 대한 작업 수행
	}

ex)	// 향상된 for 루프 
	// 원소의 타입(Object)를 활용하여 vector의 원소 순회
	for (Object element : vector) {
	    // 원소에 대한 작업 수행
	}

case3) Enumeration - Vector의 Object를 나열형으로 리턴
	- v.elements()메소드를 통해 Vector의 Object를 나열하는 Enumeration객체 생성
	- hasMoreElements() 메서드를 활용하여 가져올 데이터가 있는지 확인
	- nextElement() 메서드를 통해 값을 받아 출력
	-단, Enumeration은 삭제 작업을 지원X
ex)	Enumeration e = v.elements();

	while (e.hasMoreElements()) {
		// nextElement() 메서드를 통해 값을 받아 출력
		System.out.print(e.nextElement()+"\t");
	}
	System.out.println();


case4) Iterator - Vector의 Object를 반복하며 리턴
	- v.iterator()메소드를 통해 Vector의 Object를 반복하는 Iterator 객체 생성
	- hasNext() 메서드를 활용하여 가져올 데이터가 있는지 확인
	- next() 메서드를 통해 값을 받아 출력
	- remove() 메서드를 통해 요소를 삭제가능
ex)	Iterator ie = v.iterator();
	
	while (ie.hasNext()) {
		// next() 메서드를 통해 값을 받아 출력
		System.out.print(ie.next()+"\t");
	}
	System.out.println();









