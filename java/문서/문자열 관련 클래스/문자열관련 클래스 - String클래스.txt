* 문자열 관련 클래스 
String
StringBuffer
StringTokenizer
---------------------------------------------------------------------------------
* String 클래스 - 문자열을 다루고 표현하는데 사용

1. String객체를 생성한 후에 메소드에 의해 값의 변화가 일어나면
   변경된 값을 heap메모리 영역에 다시 저장
2. heap메모리 영역에 변경된 값을 재사용 하기 위해서는,
   새로운 변수에 변경된 값을 저장하여 사용
   ex) String str2 = str1.toUpperCase();
3. heap메모리 영역에 변경된 값을 재사용 할 수 없는 경우에는 쓰레기로 인식하고
   heap메모리 영역의 데이터를 가비지 콜렉터 프로그램이 모아서 지워버림 
     ex) str1.toUpperCase();	// 참조가능한 주소가 없어서 지워버림
4. Garbage Collection 기능(쓰레기 수집 기능)
   재사용할 수 없는 heap메모리 영역의 데이터를 모아서 지워주는 기능
   *heap메모리에 접근 불가 = 더이상 참조가능한 주소값이 없는 경우


### "문자열" 생성
1) 리터럴 방식 
String str1 = "자바";
- 문자열 생성시,  heap메모리 내의 문자열 풀(String Pool)에 저장됨
- 동일한 문자열 리터럴을 사용하는 경우, 같은 객체(주소값)을 가리키게 됨
  (같은 heap메모리 내의 문자열 풀(String Pool)을 가리킴)

2) new연산자를 사용하여 문자열 형성
: String클래스의 생성자를 호출하여 매번 "새로운" 문자열 객체 생성
  => 같은 문자열을 가리키는 변수라도 서로 다른 객체(주소값)을 참조하게 됨
String str2 =  new String("자바");
String str3 =  new String("자바");

- new연산자를 사용하면, 생성된 문자열 객체(인스턴스)들을 heap메모리에 저장됨
- heap메모리에 저장된 그 주소를 stack에 있는 변수가 참조
- 메모리 할당과 초기화가 추가적으로 발생

ex) 	String str1 = "자바";
	String str2 =  new String("자바");
	String str3 =  new String("자바");

	str1          ----->    자바
	str2          ----->    자바
	str3          ----->    자바
	(Stack영역)            (Heap영역)
	*Str변수는 stack에 할당되고, heap메모리에 있는 해당 문자열을 가리킴

### 문자열 결합/연결(String concatenation)
: 문자열 연결은 '+'연산자를 사용해서 수행
- 문자열 연결 연산('+')은 heap메모리에 새로운 문자열 객체를 생성하여 결과 반환
  (새로운 heap메모리 내의 문자열 풀(String Pool)에 저장됨)
ex)	String gemini = "gemini";
	String johnharu = "johnharu";
	// 가리키는 값들끼리 연산되어 새로운 객체에 형성됨
	String tempString1 = gemini + johnharu;

- 문자열 리터럴 방식으로 연결하는 경우
	- ***기존 String객체를 문자열 리터럴 방식으로 연결하는 경우
	   ***heap메모리에 새로운 문자열 객체를 생성하지 X
ex)	System.out.println("gemini" + "johnharu");
	// ***heap메모리에 새로운 문자열 객체를 생성하지 X

- 문자열(String) + 정수형
	- 정수값은 자동으로 문자열로 변환되어 문자열과 연결됨
	- 문자열 연결 연산으로 생성된 새로운 문자열은 새로운 heap메모리에 할당됨
ex)	String tempString2 = tempString1 + 100;
	// 새로운 문자열은 새로운 heap메모리에 할당됨


### 문자열 비교 - 주소값 / 실제값
1) 문자열의 주소값 비교 - java의 '=='연산자 사용
if (str1 == str2) { //주소값을 비교
	System.out.println("같다");
}
- 두 문자열이 동일한 heap메모리 위치(주소)를 가리키는지 확인
  (두 문자열이 같은 객체를 참조하는지 비교)
- str1과 str2는 문자열 리터럴을 참조

2) 문자열의 실제 값 비교 - equals()메소드 사용
if(str1.equals(str2)){ //실제 값을 비교
	System.out.println("같다");
}
- equals()메소드를 사용하여 boolean형 값을 return
  : 값이 같을경우 true, 다를경우 false return


----메소드-----------------------------------------------------------------------
### split(String regex) 메소드
		- 정규 표현식(Regular Expression, Regex)이 사용됨
 : 문자열을 특정 구분자를 기준으로 분리하여 "배열"로 반환하는 기능 제공
    => 주어진 문자열을 구분자를 기준응로 여러 부분 문자열로 나누는 역할

- regex : 정규표현식 또는 일반 문자열을 사용하여 문자열을 나눌 "구분자" 지정
ex)	String str = "apple,banana,orange";
	String[] fruits = str.split(",");
	// 쉼표(,)를 구분자로 사용 => split()메소드 호출하여 배열로 분리
	// => fruits[0] = "apple"; fruits[1] = "banana"; fruits[2] = "orange";

* 정규 표현식(Regular Expression, Regex)
1) 구분자 = 하나이상의 공백 : \\s+
		- 하나이상의 공백을 의미
ex)	String str = "Hello World";
	String[] wordsArray = str.split("\\s+");

*** 구분자 = 하나의공백일 경우, split(" ") 사용 가능

2) 문자 하나씩 구분하는 경우 : ""
		- 구분자로 빈문자열("")을 사용하는 경우, 문자열이 문자 하나씩 배열에 담김
ex)	String str = "Hello";
	String[] characters = str.split("");
	// split("")호출 결과 => characters[0] = "H"; ... characters[4] = "o";

3) 구분자 = 쉼표(,) : ,\\d+
		- , (쉼표)와 숫자로 된 패턴 \d+를 함께 사용
ex)	String str = "123,456,789";
	String[] values = str.split(",\\d+");

*** 구분자를 split(",")로도 사용 가능


4) 구분자를 여러개 지정하는 경우 => 파이프("|") 기호 사용
		- 여러 개의 구분자를 OR 연산으로 결합 => 어느 하나가 일치하는 경우 분리

ex)	String text = "홍길동&홍길순,김길동,김자바-안화수";
	String[] names = text.split("&|,|-");
	// text문자열을 & , - 중 하나의 구분자로 사용하여 분리


### length()메소드
 : 문자열의 길이를 구해주는 역할	*****
	int length()
- 문자열에 포함된 문자(유니코드 코드 포인트)의 개수를 세어서 반환
- 문자열이 비어있는 경우, 길이를 0으로 반환
ex)	String text = "Hello, World!";
	// 문자열 text의 길이를 구함
	int length = text.length();
	System.out.println(length); // 출력 결과: 13

cf> 배열의 크기구하는 속성 = length속성
	ex) Array.length
    자료구조에서 원소의 개수 = size()메소드
	ex) ArrayList.size


### indexOf()메소드
 : 문자열 내에서 특정 문자 또는 문자열의 인덱스를 찾을 때 사용
- 해당 문자/문자열이 처음으로 등장하는 인덱스(위치)를 반환
- 문자열 내에 해당 문자/문자열이 없는 경우 -1을 반환
- 사용법		1. 10진수 ASCII코드값에 해당하는 문자의 인덱스번호
			int index = text.indexOf(int ch);
		2. 가장먼저 나오는 str('문자')의 인덱스 번호를 구해줌
			int index = text.indexOf(String str);
		3. 검색을 시작할 인덱스 위치를 지정하여, 
		     이 인덱스 이후로 문자/문자열을 찾음
			int index = int indexOf(int ch, int fromIndex)
			int index = int indexOf(String str, int fromIndex)

ex)	String message = "Java program";
	int index1 = message.indexOf('a');
	// 가장 먼저 나오는 'a'의 인덱스 번호를 구해줌
	int index2 = message.indexOf(97);
	// 10진수 ASCII코드값(97)에 해당되는 문자('a')의 인덱스 번호를 구함
	int index3 = message.indexOf('a', 13);
	// index번호 13번째 이후에서 a의 인덱스 번호를 구해줌


### charAt(int index) 메소드
 : 문자열에서 지정한 index번호에 해당하는 문자 1개를 반환
	char charAt(int index)
			index : 반환하고자 하는 문자의 인덱스 값
- 반환값은 char 자료형으로, 문자를 유니코드 포인트로 표현하는 값
- 문자열의 각 문자에 순차적으로 접근하거나, 특정 인덱스 위치의 문자를 확인하는 작업 수행
- char자료형 비교시 '==' 연산자를 사용하여 비교
  (char자료형은 객체가아니기에, 객체간의 동등성을 비교하는 equals()메소드 사용X)
ex)	String text = "Hello, World!";
	char character = text.charAt(4);
	System.out.println(character); // 출력 결과: 'o'

ex)	//문자열(message)에서 공백의 인덱스 위치를 찾아 출력
	for (int i = 0; i < message.length(); i++) {
		char c = message.charAt(i);
		// 문자열에서 공백의 위치를 찾아서 공백의 인덱스 출력
		if (c == ' ') {
			System.out.println("index = " + i);
		}
	}


### trim()메소드
 : 문자열 좌, 우(앞, 뒤)의 공백을 없애주는 역할
- 문자열 앞/뒤의 공백만 제거(그 외의 공백은 제거X)
- 메소드 형식: String trimmedText = text.trim();
- 사용자의 입력데이터를 처리하는 경우
- 문자열을 정리하여 처리하는 경우 사용
- trim()메소드를 사용하여 앞뒤 공백을 제거한 후, equals메소드를 사용해 비교
   * boolean equals()메소드 : 문자열 실제값을 비교하는 역할
ex)	// 공백도 메모리상에 공간을 차지
	String str1 = new String("gemini   ");
	String str2 = new String("   gemini ");

	// str1과 str2의 실제값을 비교 - equals()메소드
	System.out.println(str1.equals(str2));		// false(공백때문)
	// 공백에 의해 가리키는 실제값이 다름
	// trim()메소드를 사용하여 공백을 제거한 후, equals()메소드를 사용하여 비교
	System.out.println(str1.trim().equals(str2.trim()));	// true


### substring()메소드 
: 문자열에서 특정 범위에 해당하는 "부분" 문자열을 추출하는 역할
- 원본 문자열을 변형하지 않고, 새로운 부분 문자열을 반환
-메소드 형식
	// substring(n) : index번호 n번 부터 끝까지 추출
	String substring(int beginIndex)

	// substring(n1, n2) : index번호 n1번 부터 (n2-1)번 까지 추출
	String substring(int beginIndex, int endIndex)
			* beginIndex: 추출하고자 하는 부분 문자열의 시작 인덱스(포함)
			* endIndex: 추출하고자 하는 부분 문자열의 끝 인덱스(포함X, 이전)

ex)	String text = "Hello, World!";
	// 인덱스번호 0~4번까지 문자열 추출(처음부터 4번까지)
	String sub1 = text.substring(0, 5);
	System.out.println(sub1); // 출력 결과: "Hello"

	// 인덱스번호 7번부터 끝까지 문자열 추출
	String sub2 = text.substring(7);
	System.out.println(sub2); // 출력 결과: "World!"



### 알파벳 대/소문자 변환 메소드
# toUpperCase()메소드: 문자열의 모든 영문 알파벳 문자를 대문자로 변환하는 역할
# toLowerCase()메소드 : 문자열의 모든 영문 알파벳 문자를 소문자로 변환하는 역할
- 대/소문자로 변환된 문자열의 새로운 복사본이 생성되어 반환. 복사본은 heap메모리에 저장됨
  => 원래의 문자열은 변경되지X

ex)	String text = "HELLO, WORLD!";
	String uppercaseText = text.toUpperCase();	// 대문자 변환
	System.out.println(uppercaseText); // 출력 결과: "HELLO, WORLD!"

	String lowercaseText = text.toLowerCase();	// 소문자 변환
	System.out.println(lowercaseText); // 출력 결과: "hello, world!"
	

### replace()메소드
: 문자열 내의 특정 문자/문자열을 다른 문자/문자열로 대체하는 역할 수행
- 문자열의 특정 패턴을 찾아 대체하는 역할
-메소드 형식
	String replace(char oldChar, char newChar)
	// 문자열에서 대체하고자 하는 문자(oldChar)를 찾아서 새로운문자(newChar)로 대체
	String replace(CharSequence target, CharSequence replacement)
	// 문자열에서 대체하고자 하는 문자열 패턴(target)를 찾아서 
	   새로운문자(replacement)로 대체
- 원래의 문자열은 변경되지X

- 문자열 내에서 원하는 문자를 변경/삭제하는 경우 사용
- 문자열의 대소문자변환, 공백제거 등에 사용
ex)	String text = "Hello, World!";
	String replaced1 = text.replace('l', 'L');
	System.out.println(replaced1); // 출력 결과: "HeLLo, WorLd!"

	String replaced2 = text.replace("World", "Universe");
	System.out.println(replaced2); // 출력 결과: "Hello, Universe!"



