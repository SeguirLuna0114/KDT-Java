** 레퍼런스 형변환(reference type casting) **
   - 두개의 클래스 사이에 상속관계가 있어야함

# 상속관계에서의 형 변환
* 업캐스팅(Upcasting)(자동 형변환) "하위 클래스의 정보 잃어버림"
  : 파생 클래스의 객체를 기본 클래스 타입으로 형변환하는 것 의미
	" 자식클래스의 객체를 부모클래스의 참조 변수에 할당하는 것"
		** 객체를 생성하면, 해당 객체는 heap메모리에 저장됨
		** 참조변수는 객체가 실제 존재하는 메모리 주소를 의미하며, 
		    이를 통해 객체에 접근하고 조작 가능

   1. 서브클래스에서 슈퍼클래스로 형변환 하는것(자식클래스 객체 -> 부모클래스 타입으로 변환)
	- 객체 지향 프로그래밍에서 클래스 간의 상속 관계에서 발생하는 형변환
	- 구체적인 클래스 타입 -> 일반적인 상위 클래스 타입으로 변환

   2. 참조 가능한 영역이 축소가 된다.
	- 부모클래스로부터 상속받은 멤버(필드, 메소드)만 접근 가능
	- 업캐스팅된 객체 사용시, 원래의 하위 클래스에 있는 메소드나 필드에는 접근X

   3. 컴파일러에 의해서 암시적 형변환(자동 형변환) 된다.
	- 컴파일러가 "자동으로 형변환" 해주기에, (Parent)자료형 생략 가능

   * 메소드의 매개변수가 Object인 경우 업캐스팅 사용

case1) 부모클래스 객체 선언 & 자식클래스 객체 생성
	부모클래스명 객체명;	// 부모클래스 객체 선언
   	   Parent      p;
	자식클래스 객체 = new 자식클래스 생성자	// 자식클래스 객체 생성   
	   Child   c  = new Child();
	부모클래스 객체 = 자식클래스 객체		
   		p  = c;  	//업캐스팅(자동 형변환)

case2) 부모클래스명  객체명  =  new 자식클래스명();
   	Parent p = new Child();	


# 업캐스팅과 자동 형변환(Automatic Type Conversion)
- 자동형변환: 데이터 타입이 서로 호환되는 경우에 컴파일러가 자동으로 형변환을 수행
	   	- 주로 데이터 타입이 다른 값을 연산하거나 할당하는 경우에 발생
		ex) int 타입과 double 타입을 연산 => int 값이 자동으로 double형으로 변환


## 업 캐스팅 사용하는 경우
case1) 	추상클래스의 경우, 자체적으로 객체생성이 불가능 하기에,
	하위클래스의 객체를 생성한 후, 상위클래스 타입의 참조변수에 할당
	ex) Calendar와 GregorianCalendar
	     	java.util.Calendar(상위 클래스)
      		- java.util.GregorianCalendar(하위 클래스)

		** 업캐스팅: 상속받는 하위 클래스 GregorianCalendar클래스를 사용하여 
		 	  GregorianCalendar의 객체를 만들고, 부모클래스 타입의 변수에 할당
		 	  => 자식클래스 GregorianCalendar 객체를 
			     마치 부모클래스 Calendar객체처럼 다룰 수 있음
     	     	Calendar cal = new GregorianCalendar();	
		//업캐스팅(자식객체 -> 부모클래스 변수)

		Calendar c2 = (Calendar)new GregorianCalendar();
		// 자동 형변환 되기에, (Calendar) 생략 가능


case2)	인터페이스는 new키워드를 사용하여 자체적으로 객체 생성X
	=> 대신, 인터페이스를 구현한(상속받은) 하위 클래스의 객체 생성 가능(참조변수 이용)
		"인터페이스 객체 = new 해당 인터페이스를 구현한 하위클래스"

	ex) 인터페이스를 구현한 클래스(ArrayList)는 List인터페이스를 구현한 클래스
	     따라서, ArrayList객체를 생성하여 List객체처럼 다룰 수 있음
     		ArrayList  li = new ArrayList();	// 일반적인 객체 생성 및 변수 할당
     		List  li = new ArrayList(); 			//업캐스팅
    		(인터페이스)


case3)	메소드의 매개변수가 최상위 클래스인 Object타입인 경우 업캐스팅 사용
	ex1) add(Object e)메소드: List 인터페이스에 포함되며, list에 요소를 추가하는 메소드
				기본 타입을 Wrapper클래스로 자동으로 박싱하여 list에 추가

		// int 10 -> Integer객체로 변환되어 list에 추가
		// Object e = new Integer(10) 박싱 + 업캐스팅(매개변수 Object타입)
		list.add(10);		
		
		// double 3.14 -> Double객체로 변환되어 list에 추가
		// Object e = new Double(3.14) 박싱 + 업캐스팅(매개변수 Object타입)
		list.add(3.14);
		
		// char 'j' -> Character객체로 변환되어 list에 추가
		// Object e = new Character('j') 박싱 + 업캐스팅(매개변수 Object타입)
		list.add('j');
		
		// boolean true -> Boolean객체로 변환되어 list에 추가
		// Object e = new Boolean(true) 박싱 + 업캐스팅(매개변수 Object타입)
		list.add(true);		// Object타입인 list에 그대로 추가됨
		
		// String은 기본 데이터타입X => 자동박싱X
		// 따라서, String("자바")라는 문자열 리터럴은 list에 바로 추가됨
		// String "자바" -> Character객체로 변환되어 list에 추가
		// 박싱 + 업캐스팅X(String객체는 Object클래스의 하위클래스X)
		list.add("자바");

	ex2) boolean equals(Object e)메소드 : Object 클래스에서 상속된 메소드로,
					    두 객체가 같은지 비교하는데 사용
		// (1) equals()메소드로 문자열 비교
		// Object e = new String("java");	// 업캐스팅
		// "java"는 리터럴 방식으로 생성된 문자열 => 문자열 풀에 존재
		if ("java".equals(new String("java"))) {
			System.out.println("같은 값");	// true: 동일한 문자열
		} else {
			System.out.println("같은 값");
		}
		
		// (2) equals()메소드로 정수 비교
		// Object e = new Integer(30);		// 업캐스팅
		// Object e = 30;				// 자동 박싱 + 업캐스팅
		if (new Integer(30).equals(new Integer(30))) {
			// Integer클래스는 equals()메소드를 숫자의 내용 비교하게 재정의
			System.out.println("같은 값");	// 같은값
		} else {
			System.out.println("다른 값");
		}
		
		// (3) equals() 메소드로 부동소수점 비교
		// Object e = new Integer(3.14);	// 업캐스팅
		// Object e = 3.14;				// 자동 박싱 + 업캐스팅
		if (new Double(3.14).equals(new Double(3.14))) {
			// Double 클래스는 equals()메소드를 숫자의 내용을 비교하도록 재정의
			System.out.println("같은 값");	// 같은 값
		} else {
			System.out.println("다른 값");
		}




 
   





