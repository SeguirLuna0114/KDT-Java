* 예외(Exception)  처리

    *예외(Exception) : 프로그램이 실행되는 동안에 발생하는 예상하지 못한 
          	      않은 에러를 의미 (비 정상적인 종료를 막기 위해서 사용)
	- 이러한 상황에 대응하기 위해 예외처리 필요
	- 예외 처리를 위해 try, catch, finally, throw, throws 등의 키워드를 사용
	
	- Error: 프로그램이 복구할 수 없는 심각한 오류(개발자가 해결X)
	- Exception: 프로그램이 처리할 수 있는 예외 상황

	- try블록 : 예외가 발생할 가능성이 있는 코드 작성
		   예외가 발생하면, 예외가 발생한 라인 아랫쪽의 내용은 실행되지 않고,
	  	   catch 구문에서 예외를 받아서 예외처리를 함

	- catch블록 : 예외 발생시 처리할 코드를 작성(예외를 처리하는데 사용)
		    예외가 발생하지 않으면 catch블록은 실행되지x

	- finally블록 : 예외발생 여부와 관계없이 항상 실행되는 블록.
		       예외처리 필요한 경우 뿐만이 아니라, 리소스 해제와 관련 작업 수행
			(파일을 닫거나, 데이터베이스 연결을 끊는 내용이 주로 사용)
			(ex.  file.close(), con.close() )


	- throw 키워드: 예외를 "강제로 발생시킬 때" 사용. 특정 조건에 따라 예외 발생시킴
			"프로그래머가 코드 내에서 예외를 "명시적으로 발생"시키는 경우 사용
	ex)	public static int divide(int dividend, int divisor) {
        		if (divisor == 0) {
           			// 0으로 나누는 경우 ArithmeticException 예외를 발생시킴
            			throw new ArithmeticException("Cannot divide by zero!");
        		}
       			return dividend / divisor;
    		}
		- 예외를 발생시켜야 할 상황에서 예외 객체를 생성하고,
	 	  해당 예외를 호출 스택을 따라 위로 던짐
		- 호출 스택 상에 있는 다른 메소드들은 이 예외를 적절히 처리하거나
		   더 높은 호출 스택 단계에게 예외 전달 가능
		- 예외 발생 방법)	1) throw키워드를 사용해 발생시킬 예외 객체 생성
				   - 해당 예외클래스의 생성자를 호출해 예외객체 지정 및 생성
					throw new 예외클래스();
				2) throw문 사용: throw키워드를 사용하여 
						예외 객체를 호출 스택으로 던짐
				=> 이후의 코드는 실행되지 않고, 
				   예외 발생 지점에서 예외처리 메커니즘 동작


	- throws 키워드:	발생하는 예외를 해당 메소드를 호출한 곳으로 떠넘기는 역할
			- 해당 메소드가 "호출될 때 발생할수 있는 예외"를 "명시적으로 선언"
			- 여러 예외를 던지는 경우에는 쉼표(,)로 구분
	ex)	public void someMethod() throws IOException, SQLException {
    			// 예외 발생 가능한 코드
		}
		- 메소드 선언부에 throws 키워드를 사용해 해당 메소드가 던지는 예외 명시
		- 예외를 던지는 메소드는 메소드 내에서 직접 예외처리를 하지 않고,
     		  해당 메소드를 호출한 곳에 해당 예외를 처리하도록 던짐(양도함/떠넘김)

   		- 장점) - 예외를 던지는 메소드는 예외처리를 신경쓰지 않고 작업에 집중 가능
    		 	- 호출자는 해당 예외를 처리하거나 다른 메소드에게 위임 가능

   		- case) 하나의 클래스 내에 동일한 형식의 메소드가 여러개 있는 경우,
     			throws로 예외를 던져서 예외를 한꺼번에 처리하기 위함
			ex) 메소드들은 모두 파일과 관련된 작업을 수행하는 경우
			=> 예외 처리를 각 코드마다 중복 작성하는 대신, 
	   		예외를 던지고 호출자에서 한 곳에 예외처리 가능(코드 중복 최소화)

			ex) 입출력 작업(파일 읽기, 쓰기 등)시 IOException예외 던짐
			ex)데이터베이스 작업(연결, 쿼리실행)시 SQLException 예외 던짐


1. try ~ catch 구문으로 예외처리

   try{
	예외가 발생할 가능성이 있는 문장;

   }catch(예외클래스명  매개변수){
	예외 메시지;
	예외 처리 코드;
	// 예외가 발생하지 않으면 catch블록은 실행되지x
   }


2. try ~ catch 구문으로 다중 예외 처리(Multi Exception Handling)
   - try블록 내에 여러개의 catch블록을 사용하여 여러 종류의 예외를 다르게 처리할 수 있음
   - 발생한 예외와 일치하는 catch 블록이 있는 경우 해당 catch 블록이 실행

   try{
	예외가 발생할 가능성이 있는 문장;
   }catch(예외클래스명 매개변수){
	예외 메시지;
   }catch(예외클래스명 매개변수){
	예외 메시지;
   }


3. try-catch-finally 구문으로 예외처리
   - 주로 예외처리 및 리소스 관리에 사용(DB관리 시 사용)

   try{
	예외가 발생할 가능성이 있는 문장;
   }catch(예외클래스명 매개변수){
	예외 메시지;
   }finally{
	항상 실행되는 코드(예외가 발생하든, 발생하지 않든 무조건 실행);
	// 주로 리소스를 해제하거나 프로그램 실행 완료 후 정리하는 작업에 사용됨
	//주로 파일을 닫을때, 데이터베이스 연결 끊을때 사용됨
         ex) file.close(), con.close()
   }


4. throws키워드 사용 - 메소드 선언부에서 throws 키워드 사용해, 예외처리를 떠넘김(양도)
   "해당 메소드가 "호출될 때 발생할수 있는 예외"를 "명시적으로 선언"
   - 예외를 던지는 메소드는 메소드 내에서 직접 예외처리를 하지 않고,
     해당 메소드를 호출한 곳에 해당 예외를 처리하도록 던짐(양도함/떠넘김)
   - 예외를 던지는 메소드는 예외처리를 신경쓰지 않고 작업에 집중 가능
     - 호출자는 해당 예외를 처리하거나 다른 메소드에게 위임 가능 => 코드의 유연성

     - 예외 던지는 경우) 하나의 클래스 내에 동일한 형식의 메소드가 여러개 있는 경우,
     		     throws로 예외를 던져서 예외를 한꺼번에 처리하기 위함
		     ex) 메소드들은 모두 파일과 관련된 작업을 수행하는 경우
	=> 예외 처리를 각 코드마다 중복 작성하는 대신, 
	   예외를 던지고 호출자에서 한 곳에 예외처리 가능(코드 중복 최소화)
	ex) 입출력 작업(파일 읽기, 쓰기 등)시 IOException예외 던짐
	ex) 데이터베이스 작업(연결, 쿼리실행)은 SQLException이 발생 가능하기에 예외 던짐

  class Test{
	// check()메소드에서 Exception을 던지도록 처리
       	public void check() throws Exception{
		// 예외가 발생할 가능성이 있는 작업
       	}

       	public static void main(String[] args){

	  try{        
		Test t = new Test();
		// check()메소드 호출 => check()메소드에서 발생한 예외를
		// catch 블록에서 잡아서 처리하게됨	
        	t.check();
	  } catch(Exception e) {
		// 예외를 처리하는 코드(예외 발생시 실행)
		// void printStackTrace()메소드: 예외 발생 경로 출력
		e.printStackTrace();	

		// String getMessage(): 예외 정보를 문자열로 반환함.
		System.out.println(e.getMessage());

		// String toString(): 예외의 간단한 설명문을 반환함.
		System.out.println(e.toString());
	  }
       	}
    }


5. throw키워드 사용 - 프로그래머가 "강제로" 예외를 발생시키는 방법
 - 예외를 발생시켜야 할 상황에서 예외 객체를 생성하고, 해당 예외를 호출 스택을 따라 위로 던짐
 - 1) throw키워드를 사용해 발생시킬 예외 객체 생성: throw new 예외클래스();
  2) throw문 사용: throw키워드를 사용하여 예외 객체를 호출 스택으로 던짐

 class Test{
	// check() 메서드에서 ArrayIndexOutOfBoundsException를 
	// 프로그래머가 직접 발생시키도록 구현
    	public void check() throws ArrayIndexOutOfBoundsException {
       		// ArrayIndexOutOfBoundsException: 배열의 인덱스가 범위를 벗어났을 때 발생
						  배열의 크기보다 큰 인덱스나 음수 사용시발생
		for( int i=0 ; i<10 ; i++ ) {
		  	// 예외를 던짐(프로그래머가 직접 예외를 발생시킴)
			if( i == 3 ){ 
			  	throw new ArrayIndexOutOfBoundsException();
			}			
		}
    	}

    	public static void main( String[] args ) {
		
		Test t = new Test();	
		try {
			// check()메소드 호출 => check메소드 내부에서 예외 발생
	    		t.check();
		} catch (ArrayIndexOutOfBoundsException ab ) {
			// check()메소드 내부에서 발생한 예외를 잡아내고,
			// void printStackTrace()메소드를호출하여 예외 발생 경로 출력	    
	    		ab.printStackTrace();
		}
   	}


* 예외 처리 메소드(Exception Handling Method)

- 예외 처리하는 catch 구문에서 사용되는 예외 처리 메소드
1. void printStackTrace()메소드: 예외 발생 경로(스택 트레이스) 출력
	"예외 클래스(타입) 이름 + 오류메시지 + 예외가 발생한 파일의 경로/위치 반환"
	ex)	e.printStackTrace();
	- 스택 트레이스: 예외가 발생한 원인을 알려주는 메소드 호출의 순서를 보여줌
		       디버깅 및 예외가 발생했을 때 프로그램 실행 흐름을 이해하는 데 유용

2. String getMessage(): 예외와 관련된 '오류 메시지'를 문자열로 반환함
	"오류메시지만 반환"
	ex)	String errorMessage = e.getMessage();
	- 예외가 발생하면 일반적으로 원인에 대한 설명이 포함된 메시지가 반환됨
	- 오류의 원인을 이해하는 데 도움

3. String toString(): '예외의 클래스 이름' 뒤에 '오류메시지'를 포함한 간단한 설명문을 반환함.
	"예외 클래스(타입) 이름 + 오류메시지 반환"
	ex)	 String exceptionString = e.toString();
	- 예외 객체를 문자열로 변환하여 반환
	- 예외 객체를 사람이 읽을 수 있는 문자열로 변환하여 로깅이나 디버깅 목적으로 활용




  
   