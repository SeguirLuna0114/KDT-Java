*** 참조형 - 배열(Array) ***
: 동일한 (한가지) 자료형의 데이터를 저장하기 위한 정적인 자료구조
- 인덱스를 사용하여 개별 요소에 접근 가능
- 정적인 자료구조 => 크기가 정해짐
- length()속성: 배열의 길이를 알려주는 방법. 배열에 포함된 요소의 개수 출력
- double형 배열에 int형 값을 할당해도 됨
    (이후, int형 -> double형으로 형변환 되어 출력됨)

- int형 배열은 자동으로 0으로 초기값 생성됨
- double형 배열은 자동으로 0.0으로 초기화 됨
- char형 배열은 자동으로 문자형태로 초기화 되지X
- boolean형 배열은 false값으로 초기화 됨
- String형 배열은 null값으로 초기화됨

* 1차원 배열
- 형식) type[] arrayName; 	(또는 type arrayName[];)
   (null: 값이 없음. 참조할 주소가 없음.)
	ex) int[] 	score = new 	int[3];
	    System.out.println(score[0]);	// 0
	    System.out.println(score[1]);	// 0
	    System.out.println(score[2]);	// 0

i. 배열에 저장될 값이 정해져있지 않은 경우 주로 사용
   (new 연산자를 사용하여 배열 생성 => 각 요소 개별적으로 할당)

    int[]       score     =     new        int[3];
    
   자료형       배열변수        연산자      자료형[배열의 크기(=방의 갯수)]

	(heap메모리 상에 4 byte 기억공간을 연속적으로 3개 형성)
	
   score[0]=80;
   score[1]=90;
   score[2]=100;


ii. 배열에 할당될 값이 정해진 경우 주로 사용
    (배열 선언과 동시에 초기화를 할때 주로 사용)
- 따로 배열의 크기가 정해지지는 않음
- new연산자를 사용해도 됨(사용하지 않아도 됨)
- 배열은 생성된 후에 메소드에 전달될 수 있음(배열을 생성 -> 값 초기화 -> 배열을 메소드에 전달)
  그러나, int sum2 = add({83, 90, 87});와 같이 배열을 생성하지 않고 
  중괄호({})만으로 "전달"하는 방식은 '변수선언' 이나 '배열 초기화'에서만 가능
   => int sum2 = add(new int[] {83, 90, 87}); 와 같이
       new연산자로 새로운 공간을 만든 후, 공간의 주소값을 전달하여 add메소드를 호출해야 함

    int[]  score = {80, 90, 100};		// 배열의 생성과 동시에 초기화 됨
    int[]  score = new int[]{80, 90, 100};	// 배열의 생성과 초기화를 별도로 처리
cf> int[]  score;
    score = new int[]{80, 90, 100};
    -이렇게도 적을 수 있음  

    double[] d = {3.14, 10.5, 42.195};

    char[]  c = {'j', 'a', 'v', 'a', '안'};

    String[]  str = {"java", "jsp", "oracle"};
    String[]  str = new String[]{"java", "jsp", "oracle"};

* 배열 복사 - for문으로 배열 복사
- 배열은 객체이기에, 배열 복사시에는 주소가 복사되는게 아닌
  배열의 요소들이 복사됨
  => 원본 배열과 복사된 배열은 독립적인 메모리 공간을 갖게 됨

* 객체 배열 : 객체를 참조하는 배열(배열의 각 항목이 객체인 경우)
- 참조 타입 배열: 요소의 값(정수, 실수, 논리값)을 저장X,주소값을 저장O
- 비교연산자(==): 배열의 "주소값" 비교
- equals메소드 이용: 배열의 "값" 비교
- new연산자를 사용할 경우, 새로운 공간을 형성해서 "java"라는 문자열 저장
  => 서로 다른 주소값을 가짐



* 2차원 배열
- 행(row)과 열(column)으로 구성된 데이터 구조

i. 배열에 저장될 값이 정해져있지 않은 경우 주로 사용
   (new 연산자를 사용하여 배열 생성 => 각 요소 개별적으로 할당)

   int[][]    score    =   new   int[5][3];	// 2차원 배열 생성

   자료형    배열변수    연산자     [5]:행
   			       [3]:열

   -> 정수값을 저장할 수 있는 5행 3열짜리 기억 공간을 생성 

    // 배열 요소 초기화
    score[0][0]=85;   score[0][1]=60;  score[0][2]=70;
    score[1][0]=90;   score[1][1]=95;  score[1][2]=80;
    score[2][0]=75;   score[2][1]=80;  score[2][2]=100;
    score[3][0]=80;   score[3][1]=70;  score[3][2]=95;
    score[4][0]=100;  score[4][1]=65;  score[4][2]=80;


    // 배열 요소 접근
      System.out.println(score[0][0]);	// 첫 번째 요소에 접근

    // 배열 요소 수정
    score[2][1] = 10;			// 3번째 행의 2번째 열 값 수정

    // 2차원 배열 출력
     -중첩 반복문을 사용해 각 요소를 하나씩 접근하고 출력
     -첫번째 반복문은 행(row)을 순회 -> 두번째 반복문은 열(column)을 순회

    //1. 일반적 for문 활용
    for (int i = 0; i < score.length; i++) {
 	for (int j = 0; j < score[i].length; j++) {
	    System.out.print(score[i][j]+" ");
	}
	System.out.println();
    }      

    //2. 확장 for문 활용
    for (int[] row : score) {
 	for (int element : row) {
	    System.out.print(element+" ");
	}
	System.out.println();
    }

ii. 배열에 할당될 값이 정해진 경우 주로 사용
    (배열 선언과 동시에 초기화를 할때 주로 사용)

   int [][] score = { { 85,  60,  70},     //0 행
	            { 90,  95,  80},       //1 행
	            { 75,  80, 100},       //2 행
                    { 80,  70,  95},       //3 행
	            {100,  65,  80} };     //4 행
			
### 2차원 배열 출력시, 타이틀 출력
ex) System.out.println("\t"+"과목1"+"\t"+"과목2"+"\t"+"과목3"); // 열 타이틀 출력
    for(int i=0; i<score.length; i++) {	// 행 반복
    	System.out.print("학생"+(i+1)); // 행 타이틀 출력
    	for (int j=0; j<score[i].length; j++) {	// 열 반복
    		System.out.print("\t"+score[i][j]);
    	}
    	System.out.println();		// 행 단위로 줄 바꿈
    }





























    

